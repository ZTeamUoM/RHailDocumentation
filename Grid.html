<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>RideSimulator.Grid API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>RideSimulator.Grid</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import simpy
import itertools
import numpy as np
from RideSimulator.Driver import Driver
from RideSimulator.HexGrid import HexGrid


def get_spot_locations(width: int, height: int, interval: int) -&gt; np.ndarray:
    &#34;&#34;&#34;
    :param width: width of the grid
    :param height: height of the grid
    :param interval: distance between two spots
    :return: an array of all the spot locations
    &#34;&#34;&#34;
    x_points = np.arange(0, width, interval)
    y_points = np.arange(0, height, interval)

    # If the distance to the nearest taxi spot from the corner is greater than the minimum search radius additional
    # spots are added along the edges of thr map.
    if (width - x_points[-1]) &gt; (interval / np.sqrt(2)):
        x_points = np.append(x_points, width)

    if (height - y_points[-1]) &gt; (interval / np.sqrt(2)):
        y_points = np.append(y_points, height)

    spots = np.array([list(i) for i in itertools.product(x_points, y_points)])
    return np.array([spots, len(y_points), len(x_points)], dtype=object)


class Grid(object):
    &#34;&#34;&#34;
    Handles all the information and processes related to the grid. The distances between grid units can be translated to
    real world distances using the units_per_km attribute.

    Taxi spots are used to anchor drivers into locations in the map to make it easier to find the closest driver for a
    given trip.

    A hexagon overlay is used to cluster grid locations into regions where hotspots, traffic and other features are
    calculated based on the hotspots.
    &#34;&#34;&#34;

    def __init__(self, env: simpy.Environment, width: int, height: int, interval: int, num_drivers: int,
                 hex_area: float, units_per_km: int = 1, seed: int = None):
        &#34;&#34;&#34;

        :param env: simpy environment
        :param width: width of the grid
        :param height: height of the grid
        :param interval: distance between two spots
        :param num_drivers: number of drivers in the grid
        :param hex_area: area size of a single hex tile
        :param units_per_km: number of grid units per km
        &#34;&#34;&#34;
        if seed is not None:
            np.random.seed(seed)

        self.width = width
        self.height = height
        self.interval = interval
        self.hex_overlay = HexGrid(hex_area=hex_area, width=width, height=height, units_per_km=units_per_km)
        self.taxi_spots, self.spot_height, self.spot_width = get_spot_locations(width=width, height=height,
                                                                                interval=interval)
        self.driver_pools = simpy.FilterStore(env, capacity=num_drivers)

    def get_random_location(self) -&gt; np.ndarray:
        x = np.random.randint(0, self.width)
        y = np.random.randint(0, self.height)
        return np.array([x, y])

    # Temp function to get location id until hexagons are implemented
    def get_location_id(self, location):
        grid_width = 10  # no. of cells in one axis (create 10x10 grid)
        x = np.floor((location[0] - 0) * grid_width / self.width)
        y = np.floor((location[1] - 0) * grid_width / self.height)
        return x * grid_width + y

    @staticmethod
    def get_distance(loc1: np.ndarray, loc2: np.ndarray) -&gt; float:
        distance = np.linalg.norm(loc1 - loc2)
        return np.round(distance, 1)

    def get_spot_id(self, location):
        return int(np.round(location[0]) * self.spot_height + np.round(location[1]))

    def get_nearest_spot(self, location: np.ndarray, search_radius=1) -&gt; list:
        &#34;&#34;&#34;
        Find the nearest driver spot for a given location.

        Initially it&#39;ll only return the nearest spot to the driver. When search_radius = 2, the 4 taxi spots surrounding
        the rider are returned. Afterwards, with each increment to the search_radius, all taxi spots inside a square
        centered on the driver location with a side length of search_radius are returned.

        :param location: x,y coords of the location
        :param search_radius: number of breaths the search will carry out on
        :return: a list of the closest taxi spots
        &#34;&#34;&#34;
        x_spot = location[0] / self.interval
        y_spot = location[1] / self.interval
        closet_spot = [np.round(x_spot), np.round(y_spot)]

        if search_radius == 1:
            spot_no = [self.get_spot_id(closet_spot)]

        elif search_radius == 2:
            spot_no = []
            x_points = {np.floor(x_spot), np.ceil(x_spot)}
            y_points = {np.floor(y_spot), np.ceil(y_spot)}
            spots = np.array([list(i) for i in itertools.product(x_points, y_points)])
            for spot in spots:
                spot_no.append(self.get_spot_id(spot))

        else:
            spot_no = []
            x_points = [closet_spot[0]]
            y_points = [closet_spot[1]]
            for i in range(1, search_radius - 1):
                x_points.append(max(0, closet_spot[0] - i))
                x_points.append(min(self.spot_width - 1, closet_spot[0] + i))

                y_points.append(max(0, closet_spot[1] - i))
                y_points.append(min(self.spot_height - 1, closet_spot[1] + i))

            x_points = set(x_points)
            y_points = set(y_points)

            spots = np.array([list(i) for i in itertools.product(x_points, y_points)])
            for spot in spots:
                spot_no.append(self.get_spot_id(spot))

        return spot_no

    def get_closest_drivers(self, location: np.ndarray, search_radius: int) -&gt; list:
        &#34;&#34;&#34;
        A more accurate closest driver search using driver distances of all the drivers in the closest taxi spots.
        Since this is more computationally expensive and the increment in accuracy does not outweigh the cost, this is
        not used at the moment.

        :param location: location the distances should be calculated from
        :param search_radius: number of breaths the search will carry out on
        :return: a list of driver ids sorted in the ascending order according to their distances to the location
        &#34;&#34;&#34;
        spots = self.get_nearest_spot(location, search_radius=search_radius)
        driver_ids = []
        distances = []
        for driver in self.driver_pools.items:
            if driver.spot_id in spots:
                driver_ids.append(driver.id)
                distances.append(self.get_distance(location, driver.location))

        if len(driver_ids) &gt; 0:
            _, driver_ids = zip(*sorted(zip(distances, driver_ids)))
        return driver_ids

    def assign_spot(self, driver: Driver):
        &#34;&#34;&#34;
        Assign the driver to his nearest driver pool.

        :param driver: driver object
        &#34;&#34;&#34;
        driver_loc = driver.location
        spot_id = self.get_nearest_spot(driver_loc)[0]
        driver.spot_id = spot_id
        self.driver_pools.put(driver)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="RideSimulator.Grid.get_spot_locations"><code class="name flex">
<span>def <span class="ident">get_spot_locations</span></span>(<span>width: int, height: int, interval: int) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>:param width: width of the grid
:param height: height of the grid
:param interval: distance between two spots
:return: an array of all the spot locations</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_spot_locations(width: int, height: int, interval: int) -&gt; np.ndarray:
    &#34;&#34;&#34;
    :param width: width of the grid
    :param height: height of the grid
    :param interval: distance between two spots
    :return: an array of all the spot locations
    &#34;&#34;&#34;
    x_points = np.arange(0, width, interval)
    y_points = np.arange(0, height, interval)

    # If the distance to the nearest taxi spot from the corner is greater than the minimum search radius additional
    # spots are added along the edges of thr map.
    if (width - x_points[-1]) &gt; (interval / np.sqrt(2)):
        x_points = np.append(x_points, width)

    if (height - y_points[-1]) &gt; (interval / np.sqrt(2)):
        y_points = np.append(y_points, height)

    spots = np.array([list(i) for i in itertools.product(x_points, y_points)])
    return np.array([spots, len(y_points), len(x_points)], dtype=object)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="RideSimulator.Grid.Grid"><code class="flex name class">
<span>class <span class="ident">Grid</span></span>
<span>(</span><span>env: simpy.core.Environment, width: int, height: int, interval: int, num_drivers: int, hex_area: float, units_per_km: int = 1, seed: int = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Handles all the information and processes related to the grid. The distances between grid units can be translated to
real world distances using the units_per_km attribute.</p>
<p>Taxi spots are used to anchor drivers into locations in the map to make it easier to find the closest driver for a
given trip.</p>
<p>A hexagon overlay is used to cluster grid locations into regions where hotspots, traffic and other features are
calculated based on the hotspots.</p>
<p>:param env: simpy environment
:param width: width of the grid
:param height: height of the grid
:param interval: distance between two spots
:param num_drivers: number of drivers in the grid
:param hex_area: area size of a single hex tile
:param units_per_km: number of grid units per km</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Grid(object):
    &#34;&#34;&#34;
    Handles all the information and processes related to the grid. The distances between grid units can be translated to
    real world distances using the units_per_km attribute.

    Taxi spots are used to anchor drivers into locations in the map to make it easier to find the closest driver for a
    given trip.

    A hexagon overlay is used to cluster grid locations into regions where hotspots, traffic and other features are
    calculated based on the hotspots.
    &#34;&#34;&#34;

    def __init__(self, env: simpy.Environment, width: int, height: int, interval: int, num_drivers: int,
                 hex_area: float, units_per_km: int = 1, seed: int = None):
        &#34;&#34;&#34;

        :param env: simpy environment
        :param width: width of the grid
        :param height: height of the grid
        :param interval: distance between two spots
        :param num_drivers: number of drivers in the grid
        :param hex_area: area size of a single hex tile
        :param units_per_km: number of grid units per km
        &#34;&#34;&#34;
        if seed is not None:
            np.random.seed(seed)

        self.width = width
        self.height = height
        self.interval = interval
        self.hex_overlay = HexGrid(hex_area=hex_area, width=width, height=height, units_per_km=units_per_km)
        self.taxi_spots, self.spot_height, self.spot_width = get_spot_locations(width=width, height=height,
                                                                                interval=interval)
        self.driver_pools = simpy.FilterStore(env, capacity=num_drivers)

    def get_random_location(self) -&gt; np.ndarray:
        x = np.random.randint(0, self.width)
        y = np.random.randint(0, self.height)
        return np.array([x, y])

    # Temp function to get location id until hexagons are implemented
    def get_location_id(self, location):
        grid_width = 10  # no. of cells in one axis (create 10x10 grid)
        x = np.floor((location[0] - 0) * grid_width / self.width)
        y = np.floor((location[1] - 0) * grid_width / self.height)
        return x * grid_width + y

    @staticmethod
    def get_distance(loc1: np.ndarray, loc2: np.ndarray) -&gt; float:
        distance = np.linalg.norm(loc1 - loc2)
        return np.round(distance, 1)

    def get_spot_id(self, location):
        return int(np.round(location[0]) * self.spot_height + np.round(location[1]))

    def get_nearest_spot(self, location: np.ndarray, search_radius=1) -&gt; list:
        &#34;&#34;&#34;
        Find the nearest driver spot for a given location.

        Initially it&#39;ll only return the nearest spot to the driver. When search_radius = 2, the 4 taxi spots surrounding
        the rider are returned. Afterwards, with each increment to the search_radius, all taxi spots inside a square
        centered on the driver location with a side length of search_radius are returned.

        :param location: x,y coords of the location
        :param search_radius: number of breaths the search will carry out on
        :return: a list of the closest taxi spots
        &#34;&#34;&#34;
        x_spot = location[0] / self.interval
        y_spot = location[1] / self.interval
        closet_spot = [np.round(x_spot), np.round(y_spot)]

        if search_radius == 1:
            spot_no = [self.get_spot_id(closet_spot)]

        elif search_radius == 2:
            spot_no = []
            x_points = {np.floor(x_spot), np.ceil(x_spot)}
            y_points = {np.floor(y_spot), np.ceil(y_spot)}
            spots = np.array([list(i) for i in itertools.product(x_points, y_points)])
            for spot in spots:
                spot_no.append(self.get_spot_id(spot))

        else:
            spot_no = []
            x_points = [closet_spot[0]]
            y_points = [closet_spot[1]]
            for i in range(1, search_radius - 1):
                x_points.append(max(0, closet_spot[0] - i))
                x_points.append(min(self.spot_width - 1, closet_spot[0] + i))

                y_points.append(max(0, closet_spot[1] - i))
                y_points.append(min(self.spot_height - 1, closet_spot[1] + i))

            x_points = set(x_points)
            y_points = set(y_points)

            spots = np.array([list(i) for i in itertools.product(x_points, y_points)])
            for spot in spots:
                spot_no.append(self.get_spot_id(spot))

        return spot_no

    def get_closest_drivers(self, location: np.ndarray, search_radius: int) -&gt; list:
        &#34;&#34;&#34;
        A more accurate closest driver search using driver distances of all the drivers in the closest taxi spots.
        Since this is more computationally expensive and the increment in accuracy does not outweigh the cost, this is
        not used at the moment.

        :param location: location the distances should be calculated from
        :param search_radius: number of breaths the search will carry out on
        :return: a list of driver ids sorted in the ascending order according to their distances to the location
        &#34;&#34;&#34;
        spots = self.get_nearest_spot(location, search_radius=search_radius)
        driver_ids = []
        distances = []
        for driver in self.driver_pools.items:
            if driver.spot_id in spots:
                driver_ids.append(driver.id)
                distances.append(self.get_distance(location, driver.location))

        if len(driver_ids) &gt; 0:
            _, driver_ids = zip(*sorted(zip(distances, driver_ids)))
        return driver_ids

    def assign_spot(self, driver: Driver):
        &#34;&#34;&#34;
        Assign the driver to his nearest driver pool.

        :param driver: driver object
        &#34;&#34;&#34;
        driver_loc = driver.location
        spot_id = self.get_nearest_spot(driver_loc)[0]
        driver.spot_id = spot_id
        self.driver_pools.put(driver)</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="RideSimulator.Grid.Grid.get_distance"><code class="name flex">
<span>def <span class="ident">get_distance</span></span>(<span>loc1: numpy.ndarray, loc2: numpy.ndarray) ‑> float</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def get_distance(loc1: np.ndarray, loc2: np.ndarray) -&gt; float:
    distance = np.linalg.norm(loc1 - loc2)
    return np.round(distance, 1)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="RideSimulator.Grid.Grid.assign_spot"><code class="name flex">
<span>def <span class="ident">assign_spot</span></span>(<span>self, driver: <a title="RideSimulator.Driver.Driver" href="Driver.html#RideSimulator.Driver.Driver">Driver</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Assign the driver to his nearest driver pool.</p>
<p>:param driver: driver object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def assign_spot(self, driver: Driver):
    &#34;&#34;&#34;
    Assign the driver to his nearest driver pool.

    :param driver: driver object
    &#34;&#34;&#34;
    driver_loc = driver.location
    spot_id = self.get_nearest_spot(driver_loc)[0]
    driver.spot_id = spot_id
    self.driver_pools.put(driver)</code></pre>
</details>
</dd>
<dt id="RideSimulator.Grid.Grid.get_closest_drivers"><code class="name flex">
<span>def <span class="ident">get_closest_drivers</span></span>(<span>self, location: numpy.ndarray, search_radius: int) ‑> list</span>
</code></dt>
<dd>
<div class="desc"><p>A more accurate closest driver search using driver distances of all the drivers in the closest taxi spots.
Since this is more computationally expensive and the increment in accuracy does not outweigh the cost, this is
not used at the moment.</p>
<p>:param location: location the distances should be calculated from
:param search_radius: number of breaths the search will carry out on
:return: a list of driver ids sorted in the ascending order according to their distances to the location</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_closest_drivers(self, location: np.ndarray, search_radius: int) -&gt; list:
    &#34;&#34;&#34;
    A more accurate closest driver search using driver distances of all the drivers in the closest taxi spots.
    Since this is more computationally expensive and the increment in accuracy does not outweigh the cost, this is
    not used at the moment.

    :param location: location the distances should be calculated from
    :param search_radius: number of breaths the search will carry out on
    :return: a list of driver ids sorted in the ascending order according to their distances to the location
    &#34;&#34;&#34;
    spots = self.get_nearest_spot(location, search_radius=search_radius)
    driver_ids = []
    distances = []
    for driver in self.driver_pools.items:
        if driver.spot_id in spots:
            driver_ids.append(driver.id)
            distances.append(self.get_distance(location, driver.location))

    if len(driver_ids) &gt; 0:
        _, driver_ids = zip(*sorted(zip(distances, driver_ids)))
    return driver_ids</code></pre>
</details>
</dd>
<dt id="RideSimulator.Grid.Grid.get_location_id"><code class="name flex">
<span>def <span class="ident">get_location_id</span></span>(<span>self, location)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_location_id(self, location):
    grid_width = 10  # no. of cells in one axis (create 10x10 grid)
    x = np.floor((location[0] - 0) * grid_width / self.width)
    y = np.floor((location[1] - 0) * grid_width / self.height)
    return x * grid_width + y</code></pre>
</details>
</dd>
<dt id="RideSimulator.Grid.Grid.get_nearest_spot"><code class="name flex">
<span>def <span class="ident">get_nearest_spot</span></span>(<span>self, location: numpy.ndarray, search_radius=1) ‑> list</span>
</code></dt>
<dd>
<div class="desc"><p>Find the nearest driver spot for a given location.</p>
<p>Initially it'll only return the nearest spot to the driver. When search_radius = 2, the 4 taxi spots surrounding
the rider are returned. Afterwards, with each increment to the search_radius, all taxi spots inside a square
centered on the driver location with a side length of search_radius are returned.</p>
<p>:param location: x,y coords of the location
:param search_radius: number of breaths the search will carry out on
:return: a list of the closest taxi spots</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_nearest_spot(self, location: np.ndarray, search_radius=1) -&gt; list:
    &#34;&#34;&#34;
    Find the nearest driver spot for a given location.

    Initially it&#39;ll only return the nearest spot to the driver. When search_radius = 2, the 4 taxi spots surrounding
    the rider are returned. Afterwards, with each increment to the search_radius, all taxi spots inside a square
    centered on the driver location with a side length of search_radius are returned.

    :param location: x,y coords of the location
    :param search_radius: number of breaths the search will carry out on
    :return: a list of the closest taxi spots
    &#34;&#34;&#34;
    x_spot = location[0] / self.interval
    y_spot = location[1] / self.interval
    closet_spot = [np.round(x_spot), np.round(y_spot)]

    if search_radius == 1:
        spot_no = [self.get_spot_id(closet_spot)]

    elif search_radius == 2:
        spot_no = []
        x_points = {np.floor(x_spot), np.ceil(x_spot)}
        y_points = {np.floor(y_spot), np.ceil(y_spot)}
        spots = np.array([list(i) for i in itertools.product(x_points, y_points)])
        for spot in spots:
            spot_no.append(self.get_spot_id(spot))

    else:
        spot_no = []
        x_points = [closet_spot[0]]
        y_points = [closet_spot[1]]
        for i in range(1, search_radius - 1):
            x_points.append(max(0, closet_spot[0] - i))
            x_points.append(min(self.spot_width - 1, closet_spot[0] + i))

            y_points.append(max(0, closet_spot[1] - i))
            y_points.append(min(self.spot_height - 1, closet_spot[1] + i))

        x_points = set(x_points)
        y_points = set(y_points)

        spots = np.array([list(i) for i in itertools.product(x_points, y_points)])
        for spot in spots:
            spot_no.append(self.get_spot_id(spot))

    return spot_no</code></pre>
</details>
</dd>
<dt id="RideSimulator.Grid.Grid.get_random_location"><code class="name flex">
<span>def <span class="ident">get_random_location</span></span>(<span>self) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_random_location(self) -&gt; np.ndarray:
    x = np.random.randint(0, self.width)
    y = np.random.randint(0, self.height)
    return np.array([x, y])</code></pre>
</details>
</dd>
<dt id="RideSimulator.Grid.Grid.get_spot_id"><code class="name flex">
<span>def <span class="ident">get_spot_id</span></span>(<span>self, location)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_spot_id(self, location):
    return int(np.round(location[0]) * self.spot_height + np.round(location[1]))</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="RideSimulator" href="index.html">RideSimulator</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="RideSimulator.Grid.get_spot_locations" href="#RideSimulator.Grid.get_spot_locations">get_spot_locations</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="RideSimulator.Grid.Grid" href="#RideSimulator.Grid.Grid">Grid</a></code></h4>
<ul class="two-column">
<li><code><a title="RideSimulator.Grid.Grid.assign_spot" href="#RideSimulator.Grid.Grid.assign_spot">assign_spot</a></code></li>
<li><code><a title="RideSimulator.Grid.Grid.get_closest_drivers" href="#RideSimulator.Grid.Grid.get_closest_drivers">get_closest_drivers</a></code></li>
<li><code><a title="RideSimulator.Grid.Grid.get_distance" href="#RideSimulator.Grid.Grid.get_distance">get_distance</a></code></li>
<li><code><a title="RideSimulator.Grid.Grid.get_location_id" href="#RideSimulator.Grid.Grid.get_location_id">get_location_id</a></code></li>
<li><code><a title="RideSimulator.Grid.Grid.get_nearest_spot" href="#RideSimulator.Grid.Grid.get_nearest_spot">get_nearest_spot</a></code></li>
<li><code><a title="RideSimulator.Grid.Grid.get_random_location" href="#RideSimulator.Grid.Grid.get_random_location">get_random_location</a></code></li>
<li><code><a title="RideSimulator.Grid.Grid.get_spot_id" href="#RideSimulator.Grid.Grid.get_spot_id">get_spot_id</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>