<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>RideSimulator.TripGenerator API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>RideSimulator.TripGenerator</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import os
import simpy
import numpy as np
from pathlib import Path
from RideSimulator.Grid import Grid
from RideSimulator.Trip import Trip

lat_points, lon_points, trip_distances, trips_per_min = None, None, None, None


def read_data(directory=&#34;RideSimulator/data&#34;, lon_file=&#34;lon_points&#34;, lat_file=&#34;lat_points&#34;, distance_file=&#34;trip_distances&#34;,
              min_file=&#34;trips_per_min&#34;):
    global lat_points, lon_points, trip_distances, trips_per_min
    data_path = directory
    if Path(os.getcwd()).parts[-1] != &#34;RideSimulator&#34;:
        data_path = os.path.join(Path(os.getcwd()).parent, os.path.join(&#39;aaivu-ride-hailing-simulation&#39;, directory))

    print(&#34;Loading trip data...&#34;)
    lat_points = np.loadtxt(os.path.join(data_path, lat_file))
    lon_points = np.loadtxt(os.path.join(data_path, lon_file))
    trip_distances = np.loadtxt(os.path.join(data_path, distance_file))
    trips_per_min = np.loadtxt(os.path.join(data_path, min_file))
    print(&#34;Data loading complete&#34;)


class TripGenerator(object):
    def __init__(self, grid: Grid, time_unit, trips_per_week=20000, seed: int = None):
        if seed is not None:
            np.random.seed(seed)

        self.id = 0
        self.grid = grid
        self.width = grid.width
        self.height = grid.height
        self.granularity = 1000
        self.min_trip_distance = self.width / 100
        self.max_displacement = self.width * 0.05 * self.granularity

        self.time_unit = time_unit
        self.units_per_day = time_unit * 60 * 24
        time_slice = self.units_per_day // 24
        self.peak_times = [time_slice * 4, time_slice * 5, time_slice * 14, time_slice * 15]

        self.lat_points, self.lon_points, self.trip_distances = self.import_data()
        self.trips_per_min = self.scale_trip_count(trips_per_week)
        self.updated_hex_ids = set()

    def import_data(self):

        lat_points_copy = lat_points.copy()
        lon_points_copy = lon_points.copy()
        trip_distances_copy = trip_distances.copy()

        np.random.shuffle(lat_points_copy)
        np.random.shuffle(lon_points_copy)
        np.random.shuffle(trip_distances_copy)

        lat_points_scaled = lat_points_copy - lat_points_copy.min()
        lon_points_scaled = lon_points - lon_points_copy.min()

        lat_scale = self.height / lat_points_scaled.max()
        lon_scale = self.width / lon_points_scaled.max()
        distance_scale = self.width / trip_distances_copy.max()

        lat_points_scaled = lat_points_scaled * lat_scale
        lon_points_scaled = lon_points_scaled * lon_scale
        distances_scaled = trip_distances * distance_scale

        return lat_points_scaled, lon_points_scaled, distances_scaled

    @staticmethod
    def scale_trip_count(trips_per_week):
        scale = trips_per_min.sum() * 7 // trips_per_week
        scaled_hourly = (trips_per_min / scale).astype(int)
        dif = 0
        sampled_trips = []
        for i in range(24):
            h = i * 60
            full_trips = (trips_per_min[h:h + 60] / scale) // 1
            prob_trips = (trips_per_min[h:h + 60] / scale) % 1
            total_trips = []

            sample_trips = (np.random.rand(60) &lt; prob_trips).astype(int)
            total_trips += (full_trips + sample_trips).tolist()

            sampled_trips += (full_trips + sample_trips).tolist()
            trip_count = int(sum(total_trips) / 100)
            dif += trip_count - scaled_hourly[i]

        return np.array(sampled_trips).astype(int)

    def get_trip_locations(self, x, y, distance):

        x = min(self.width, x + np.random.randint(0, self.max_displacement) / self.granularity)
        y = min(self.height, y + np.random.randint(0, self.max_displacement) / self.granularity)

        start_hex = self.grid.hex_overlay.get_closest_hex([x, y])
        start_hex.trip_count += 1

        theta = np.rad2deg(np.random.random() * 2 * np.pi)

        while distance &lt; self.min_trip_distance:
            distance = distance * 1.5

        while True:
            d_x = x + distance * np.cos(theta)
            d_y = y + distance * np.sin(theta)

            x_count = 0
            y_count = 0

            while (d_x &gt; self.width or d_x &lt; 0) and x_count &lt; 2:
                # print(&#34;switching x direction&#34;, d_x)
                d_x = x - distance * np.cos(theta)
                x_count += 1

            while (d_y &gt; self.height or d_y &lt; 0) and y_count &lt; 2:
                # print(&#34;switching y direction&#34;, d_y)
                d_y = y - distance * np.sin(theta)
                y_count += 1

            if x_count == 2 or y_count == 2:
                # print(&#34;Reducing distance&#34;, distance)
                distance = distance / 2
            else:
                prob = np.random.random()
                if prob &lt; 0.2:
                    return np.array([[d_x, d_y], [x, y], [start_hex.id, start_hex.additional_reward]])
                else:
                    return np.array([[x, y], [d_x, d_y], [start_hex.id, start_hex.additional_reward]])

    def create_trip(self, env: simpy.Environment, trip_id: int) -&gt; Trip:
        &#34;&#34;&#34;
        Creates a trip in the env with the given trip_id.
        The trip will have randomly generated pickup and drop locations, and the id of the nearest driver pool is
        assigned to the trip.
        Pickup and drop locations will not be the same.

        :param env: simpy environment
        :param trip_id: trip id
        :return: trip object
        &#34;&#34;&#34;
        distance = self.trip_distances[trip_id]
        pick_up_loc, drop_loc, hex_data = self.get_trip_locations(self.lon_points[trip_id], self.lat_points[trip_id],
                                                                  distance)
        self.updated_hex_ids.add(hex_data[0])
        nearest_spot = self.grid.get_nearest_spot(pick_up_loc)[0]
        trip_i = Trip(env, trip_id, pick_up_loc, drop_loc, [nearest_spot], hex_data[0], hex_data[1])
        return trip_i

    def generate_trips(self, env: simpy.Environment):
        peak_time = False
        day_time = int((env.now % self.units_per_day) / self.time_unit)
        num_trips = self.trips_per_min[day_time]
        trips = []
        for _ in range(num_trips):
            trips.append(self.create_trip(env, self.id))
            self.id += 1

        return trips, peak_time</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="RideSimulator.TripGenerator.read_data"><code class="name flex">
<span>def <span class="ident">read_data</span></span>(<span>directory='RideSimulator/data', lon_file='lon_points', lat_file='lat_points', distance_file='trip_distances', min_file='trips_per_min')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_data(directory=&#34;RideSimulator/data&#34;, lon_file=&#34;lon_points&#34;, lat_file=&#34;lat_points&#34;, distance_file=&#34;trip_distances&#34;,
              min_file=&#34;trips_per_min&#34;):
    global lat_points, lon_points, trip_distances, trips_per_min
    data_path = directory
    if Path(os.getcwd()).parts[-1] != &#34;RideSimulator&#34;:
        data_path = os.path.join(Path(os.getcwd()).parent, os.path.join(&#39;aaivu-ride-hailing-simulation&#39;, directory))

    print(&#34;Loading trip data...&#34;)
    lat_points = np.loadtxt(os.path.join(data_path, lat_file))
    lon_points = np.loadtxt(os.path.join(data_path, lon_file))
    trip_distances = np.loadtxt(os.path.join(data_path, distance_file))
    trips_per_min = np.loadtxt(os.path.join(data_path, min_file))
    print(&#34;Data loading complete&#34;)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="RideSimulator.TripGenerator.TripGenerator"><code class="flex name class">
<span>class <span class="ident">TripGenerator</span></span>
<span>(</span><span>grid: <a title="RideSimulator.Grid.Grid" href="Grid.html#RideSimulator.Grid.Grid">Grid</a>, time_unit, trips_per_week=20000, seed: int = None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TripGenerator(object):
    def __init__(self, grid: Grid, time_unit, trips_per_week=20000, seed: int = None):
        if seed is not None:
            np.random.seed(seed)

        self.id = 0
        self.grid = grid
        self.width = grid.width
        self.height = grid.height
        self.granularity = 1000
        self.min_trip_distance = self.width / 100
        self.max_displacement = self.width * 0.05 * self.granularity

        self.time_unit = time_unit
        self.units_per_day = time_unit * 60 * 24
        time_slice = self.units_per_day // 24
        self.peak_times = [time_slice * 4, time_slice * 5, time_slice * 14, time_slice * 15]

        self.lat_points, self.lon_points, self.trip_distances = self.import_data()
        self.trips_per_min = self.scale_trip_count(trips_per_week)
        self.updated_hex_ids = set()

    def import_data(self):

        lat_points_copy = lat_points.copy()
        lon_points_copy = lon_points.copy()
        trip_distances_copy = trip_distances.copy()

        np.random.shuffle(lat_points_copy)
        np.random.shuffle(lon_points_copy)
        np.random.shuffle(trip_distances_copy)

        lat_points_scaled = lat_points_copy - lat_points_copy.min()
        lon_points_scaled = lon_points - lon_points_copy.min()

        lat_scale = self.height / lat_points_scaled.max()
        lon_scale = self.width / lon_points_scaled.max()
        distance_scale = self.width / trip_distances_copy.max()

        lat_points_scaled = lat_points_scaled * lat_scale
        lon_points_scaled = lon_points_scaled * lon_scale
        distances_scaled = trip_distances * distance_scale

        return lat_points_scaled, lon_points_scaled, distances_scaled

    @staticmethod
    def scale_trip_count(trips_per_week):
        scale = trips_per_min.sum() * 7 // trips_per_week
        scaled_hourly = (trips_per_min / scale).astype(int)
        dif = 0
        sampled_trips = []
        for i in range(24):
            h = i * 60
            full_trips = (trips_per_min[h:h + 60] / scale) // 1
            prob_trips = (trips_per_min[h:h + 60] / scale) % 1
            total_trips = []

            sample_trips = (np.random.rand(60) &lt; prob_trips).astype(int)
            total_trips += (full_trips + sample_trips).tolist()

            sampled_trips += (full_trips + sample_trips).tolist()
            trip_count = int(sum(total_trips) / 100)
            dif += trip_count - scaled_hourly[i]

        return np.array(sampled_trips).astype(int)

    def get_trip_locations(self, x, y, distance):

        x = min(self.width, x + np.random.randint(0, self.max_displacement) / self.granularity)
        y = min(self.height, y + np.random.randint(0, self.max_displacement) / self.granularity)

        start_hex = self.grid.hex_overlay.get_closest_hex([x, y])
        start_hex.trip_count += 1

        theta = np.rad2deg(np.random.random() * 2 * np.pi)

        while distance &lt; self.min_trip_distance:
            distance = distance * 1.5

        while True:
            d_x = x + distance * np.cos(theta)
            d_y = y + distance * np.sin(theta)

            x_count = 0
            y_count = 0

            while (d_x &gt; self.width or d_x &lt; 0) and x_count &lt; 2:
                # print(&#34;switching x direction&#34;, d_x)
                d_x = x - distance * np.cos(theta)
                x_count += 1

            while (d_y &gt; self.height or d_y &lt; 0) and y_count &lt; 2:
                # print(&#34;switching y direction&#34;, d_y)
                d_y = y - distance * np.sin(theta)
                y_count += 1

            if x_count == 2 or y_count == 2:
                # print(&#34;Reducing distance&#34;, distance)
                distance = distance / 2
            else:
                prob = np.random.random()
                if prob &lt; 0.2:
                    return np.array([[d_x, d_y], [x, y], [start_hex.id, start_hex.additional_reward]])
                else:
                    return np.array([[x, y], [d_x, d_y], [start_hex.id, start_hex.additional_reward]])

    def create_trip(self, env: simpy.Environment, trip_id: int) -&gt; Trip:
        &#34;&#34;&#34;
        Creates a trip in the env with the given trip_id.
        The trip will have randomly generated pickup and drop locations, and the id of the nearest driver pool is
        assigned to the trip.
        Pickup and drop locations will not be the same.

        :param env: simpy environment
        :param trip_id: trip id
        :return: trip object
        &#34;&#34;&#34;
        distance = self.trip_distances[trip_id]
        pick_up_loc, drop_loc, hex_data = self.get_trip_locations(self.lon_points[trip_id], self.lat_points[trip_id],
                                                                  distance)
        self.updated_hex_ids.add(hex_data[0])
        nearest_spot = self.grid.get_nearest_spot(pick_up_loc)[0]
        trip_i = Trip(env, trip_id, pick_up_loc, drop_loc, [nearest_spot], hex_data[0], hex_data[1])
        return trip_i

    def generate_trips(self, env: simpy.Environment):
        peak_time = False
        day_time = int((env.now % self.units_per_day) / self.time_unit)
        num_trips = self.trips_per_min[day_time]
        trips = []
        for _ in range(num_trips):
            trips.append(self.create_trip(env, self.id))
            self.id += 1

        return trips, peak_time</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="RideSimulator.TripGenerator.TripGenerator.scale_trip_count"><code class="name flex">
<span>def <span class="ident">scale_trip_count</span></span>(<span>trips_per_week)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def scale_trip_count(trips_per_week):
    scale = trips_per_min.sum() * 7 // trips_per_week
    scaled_hourly = (trips_per_min / scale).astype(int)
    dif = 0
    sampled_trips = []
    for i in range(24):
        h = i * 60
        full_trips = (trips_per_min[h:h + 60] / scale) // 1
        prob_trips = (trips_per_min[h:h + 60] / scale) % 1
        total_trips = []

        sample_trips = (np.random.rand(60) &lt; prob_trips).astype(int)
        total_trips += (full_trips + sample_trips).tolist()

        sampled_trips += (full_trips + sample_trips).tolist()
        trip_count = int(sum(total_trips) / 100)
        dif += trip_count - scaled_hourly[i]

    return np.array(sampled_trips).astype(int)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="RideSimulator.TripGenerator.TripGenerator.create_trip"><code class="name flex">
<span>def <span class="ident">create_trip</span></span>(<span>self, env: simpy.core.Environment, trip_id: int) ‑> <a title="RideSimulator.Trip.Trip" href="Trip.html#RideSimulator.Trip.Trip">Trip</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates a trip in the env with the given trip_id.
The trip will have randomly generated pickup and drop locations, and the id of the nearest driver pool is
assigned to the trip.
Pickup and drop locations will not be the same.</p>
<p>:param env: simpy environment
:param trip_id: trip id
:return: trip object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_trip(self, env: simpy.Environment, trip_id: int) -&gt; Trip:
    &#34;&#34;&#34;
    Creates a trip in the env with the given trip_id.
    The trip will have randomly generated pickup and drop locations, and the id of the nearest driver pool is
    assigned to the trip.
    Pickup and drop locations will not be the same.

    :param env: simpy environment
    :param trip_id: trip id
    :return: trip object
    &#34;&#34;&#34;
    distance = self.trip_distances[trip_id]
    pick_up_loc, drop_loc, hex_data = self.get_trip_locations(self.lon_points[trip_id], self.lat_points[trip_id],
                                                              distance)
    self.updated_hex_ids.add(hex_data[0])
    nearest_spot = self.grid.get_nearest_spot(pick_up_loc)[0]
    trip_i = Trip(env, trip_id, pick_up_loc, drop_loc, [nearest_spot], hex_data[0], hex_data[1])
    return trip_i</code></pre>
</details>
</dd>
<dt id="RideSimulator.TripGenerator.TripGenerator.generate_trips"><code class="name flex">
<span>def <span class="ident">generate_trips</span></span>(<span>self, env: simpy.core.Environment)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_trips(self, env: simpy.Environment):
    peak_time = False
    day_time = int((env.now % self.units_per_day) / self.time_unit)
    num_trips = self.trips_per_min[day_time]
    trips = []
    for _ in range(num_trips):
        trips.append(self.create_trip(env, self.id))
        self.id += 1

    return trips, peak_time</code></pre>
</details>
</dd>
<dt id="RideSimulator.TripGenerator.TripGenerator.get_trip_locations"><code class="name flex">
<span>def <span class="ident">get_trip_locations</span></span>(<span>self, x, y, distance)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_trip_locations(self, x, y, distance):

    x = min(self.width, x + np.random.randint(0, self.max_displacement) / self.granularity)
    y = min(self.height, y + np.random.randint(0, self.max_displacement) / self.granularity)

    start_hex = self.grid.hex_overlay.get_closest_hex([x, y])
    start_hex.trip_count += 1

    theta = np.rad2deg(np.random.random() * 2 * np.pi)

    while distance &lt; self.min_trip_distance:
        distance = distance * 1.5

    while True:
        d_x = x + distance * np.cos(theta)
        d_y = y + distance * np.sin(theta)

        x_count = 0
        y_count = 0

        while (d_x &gt; self.width or d_x &lt; 0) and x_count &lt; 2:
            # print(&#34;switching x direction&#34;, d_x)
            d_x = x - distance * np.cos(theta)
            x_count += 1

        while (d_y &gt; self.height or d_y &lt; 0) and y_count &lt; 2:
            # print(&#34;switching y direction&#34;, d_y)
            d_y = y - distance * np.sin(theta)
            y_count += 1

        if x_count == 2 or y_count == 2:
            # print(&#34;Reducing distance&#34;, distance)
            distance = distance / 2
        else:
            prob = np.random.random()
            if prob &lt; 0.2:
                return np.array([[d_x, d_y], [x, y], [start_hex.id, start_hex.additional_reward]])
            else:
                return np.array([[x, y], [d_x, d_y], [start_hex.id, start_hex.additional_reward]])</code></pre>
</details>
</dd>
<dt id="RideSimulator.TripGenerator.TripGenerator.import_data"><code class="name flex">
<span>def <span class="ident">import_data</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def import_data(self):

    lat_points_copy = lat_points.copy()
    lon_points_copy = lon_points.copy()
    trip_distances_copy = trip_distances.copy()

    np.random.shuffle(lat_points_copy)
    np.random.shuffle(lon_points_copy)
    np.random.shuffle(trip_distances_copy)

    lat_points_scaled = lat_points_copy - lat_points_copy.min()
    lon_points_scaled = lon_points - lon_points_copy.min()

    lat_scale = self.height / lat_points_scaled.max()
    lon_scale = self.width / lon_points_scaled.max()
    distance_scale = self.width / trip_distances_copy.max()

    lat_points_scaled = lat_points_scaled * lat_scale
    lon_points_scaled = lon_points_scaled * lon_scale
    distances_scaled = trip_distances * distance_scale

    return lat_points_scaled, lon_points_scaled, distances_scaled</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="RideSimulator" href="index.html">RideSimulator</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="RideSimulator.TripGenerator.read_data" href="#RideSimulator.TripGenerator.read_data">read_data</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="RideSimulator.TripGenerator.TripGenerator" href="#RideSimulator.TripGenerator.TripGenerator">TripGenerator</a></code></h4>
<ul class="">
<li><code><a title="RideSimulator.TripGenerator.TripGenerator.create_trip" href="#RideSimulator.TripGenerator.TripGenerator.create_trip">create_trip</a></code></li>
<li><code><a title="RideSimulator.TripGenerator.TripGenerator.generate_trips" href="#RideSimulator.TripGenerator.TripGenerator.generate_trips">generate_trips</a></code></li>
<li><code><a title="RideSimulator.TripGenerator.TripGenerator.get_trip_locations" href="#RideSimulator.TripGenerator.TripGenerator.get_trip_locations">get_trip_locations</a></code></li>
<li><code><a title="RideSimulator.TripGenerator.TripGenerator.import_data" href="#RideSimulator.TripGenerator.TripGenerator.import_data">import_data</a></code></li>
<li><code><a title="RideSimulator.TripGenerator.TripGenerator.scale_trip_count" href="#RideSimulator.TripGenerator.TripGenerator.scale_trip_count">scale_trip_count</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>